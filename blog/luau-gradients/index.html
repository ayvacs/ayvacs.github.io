<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="/styles/colours.css">
    <link rel="stylesheet" href="/styles/blogpost.css">
</head>

<body>
    <div id="blog_main">
        <h3 id="header">AYVACS <a href="../../">home</a></h3>
        <p id="date">Dec 4, 2025</p>
        <h1>gradients in tables, Luau&#39;s superpower</h1>

        <hr>

        <div id="blog-content"><pre><code class="language-lua">local gradient = gradient.new(Color3.new(1, 0, 0), Color3.new(0, 0, 1), 10)

print(gradient:at(1))     -- First step (pure red)
print(gradient:lerp(1/2)) -- Midpoint between red and blue
</code></pre>
<p>The above code creates a smooth 10-step colour gradient between two <code>Color3</code> values. What's interesting isn't <em>what</em> this code does, but rather how cleanly the API is designed and how it takes advantage of Luau's strengths as an engine.</p>
<p>So let's take a look at how my code works under the hood.</p>
<p>At the core of the module is a small helper lerp function:</p>
<pre><code class="language-lua">local function lerp(t, r1, g1, b1, r2, g2, b2)
    return Color3.new(
        r1 + (r2 - r1) * t,
        g1 + (g2 - g1) * t,
        b1 + (b2 - b1) * t
    )
end
</code></pre>
<p>Nothing fancy at all. Just basic linear interpolation between two sets of RGB values at some interval <code>0 ≤ t ≤ 1</code>. But combined with a simple for-loop, we can now generate a whole table of evenly spaced steps:</p>
<pre><code class="language-lua">local function calculateSteps(from: Color3, to: Color3, steps: number)
    local arr = {}

    local r1, g1, b1 = from.R, from.G, from.B
    local r2, g2, b2 = to.R, to.G, to.B

    for i = 0, (steps - 1) do
        local t = i / (steps - 1)
        arr[i + 1] = lerp(t, r1, g1, b1, r2, g2, b2)
    end
    
    return arr
end
</code></pre>
<p>This is essentially the &quot;pre-baked&quot; form of the gradient, an array of colours ready to be fetched, animated, iterated over, or applied to UI elements or 3D objects.</p>
<p>Where things really get interesting though is in the constructor.</p>
<pre><code class="language-lua">gradient.new = function(from: Color3, to: Color3, steps: number)
    -- ...

    local steps = calculateSteps(from, to, steps)

    return {
        at = function(self, t: number)
            return steps[t]
        end,

        lerp = function(self, t: number)
            t = math.clamp(t, 0, 1)
            return lerp(t, from.R, from.G, from.B, to.R, to.G, to.B)
        end,

        all = function(self)
            return table.clone(steps)
        end,

        iter = function(self)
            local i = 0
            return function()
                i += 1
                return steps[i]
            end
        end
    }
end
</code></pre>
<p>This isn't a traditional &quot;class&quot;, just a table containing functions, and this is one of the great things about Luau: you can build extremely lightweight, ergonomic APIs that run exactly like classes but are, at their core, literally just tables with methods attached.</p>
<p>This gradient object offers everything classes could, like:</p>
<pre><code class="language-lua">local colour = gradient:at(3)
</code></pre>
<p>Readable and intuitive: give me the colour at step 3.</p>
<pre><code class="language-lua">local smooth = gradient:lerp(1/3)
</code></pre>
<p>Instead of being limited to discrete steps, you can request colours at any point between the start and end colours. This is also readable and intuitive: give me the colour a third of the way through the gradient. Perfect for animations and dynamic UI transitions.</p>
<pre><code class="language-lua">for colour in gradient:iter() do
    print(colour)
end
</code></pre>
<p>Sometimes all you need is a lightweight iterator. No <code>ipairs</code> or indexing, just a clean and sequential walk through the gradient.</p>
<p>This stype of API (small helper functions, wrapped in neat readable interfaces) are what I believe Luau's superpower is. Just like expressive function-call notations from my previous blog post, <strong>a well-designed object can make your code both clear and pleasant to work with</strong>. Everything here is written in plain Luau with no magic involved. Just tables!</p>
<p>If you're interested, the full source code for my gradient library is available <a href="https://github.com/ayvacs/gradient">on GitHub</a>.</p>
</div>

        <hr>

        <p id="copyright">&copy; 2025 ayvacs. all rights reserved. <a id="view-source"></a></p>
    </div>

    <!-- Add view edit history btn -->
    <script>
        const pageurl = "/blog/luau-gradients/";
        const btn = document.getElementById("view-source");

        btn.href = `https://github.com/ayvacs/ayvacs.github.io/commits/main/docs${ pageurl.substring(0, pageurl.length - 1) }.md`;
        btn.textContent = "view edit history";
    </script>

    <!-- Add hightlight.js syntax highlighting for codeblocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        /* hljs override styles */
                .hljs { background: none; }
        pre code.hljs { padding: 0; }
    </style>
</body>

</html>